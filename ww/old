package main

import (
	"encoding/json"
	"fmt"
	"image"
	"image/color"
	"io/ioutil"
	"net/http"
	"syscall"
	"time"
	"unsafe"

	"github.com/fogleman/gg"
	"github.com/lxn/win"
	"golang.org/x/sys/windows"
)

// Screen dimensions (adjust to your resolution)
const (
	screenWidth  = 1920
	screenHeight = 1080
	entityMax    = 64
)

// Offset structure for dynamic fetching
type Offsets struct {
	ClientDLL map[string]uint32 `json:"client.dll"`
}

// Global variable for offsets
var offsets Offsets

// Fetch offsets from the given URL
func fetchOffsets(url string) error {
	resp, err := http.Get(url)
	if err != nil {
		return fmt.Errorf("failed to fetch offsets: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("failed to fetch offsets: status %d", resp.StatusCode)
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read response body: %w", err)
	}

	err = json.Unmarshal(body, &offsets)
	if err != nil {
		return fmt.Errorf("failed to parse JSON: %w", err)
	}

	fmt.Println("Offsets successfully loaded!", offsets)
	return nil
}

// Memory reading helper functions
func ReadMemory(handle windows.Handle, address uintptr, buffer unsafe.Pointer, size uint32) error {
	var bytesRead uintptr
	return windows.ReadProcessMemory(handle, address, (*byte)(buffer), uintptr(size), &bytesRead)
}

func ReadUint64(handle windows.Handle, address uintptr) (uint64, error) {
	var value uint64
	err := ReadMemory(handle, address, unsafe.Pointer(&value), uint32(unsafe.Sizeof(value)))
	return value, err
}

func ReadInt32(handle windows.Handle, address uintptr) (int32, error) {
	var value int32
	err := ReadMemory(handle, address, unsafe.Pointer(&value), uint32(unsafe.Sizeof(value)))
	return value, err
}

func WriteBool(handle windows.Handle, address uintptr, value bool) error {
	var val byte
	if value {
		val = 1
	}
	return windows.WriteProcessMemory(handle, address, (*byte)(unsafe.Pointer(&val)), 1, nil)
}

// Simulate a mouse click
func simulateMouseClick() {
	input := []win.MOUSE_INPUT{
		{
			Type: win.INPUT_MOUSE,
			Mi:   win.MOUSEINPUT{DwFlags: win.MOUSEEVENTF_LEFTDOWN},
		},
		{
			Type: win.INPUT_MOUSE,
			Mi:   win.MOUSEINPUT{DwFlags: win.MOUSEEVENTF_LEFTUP},
		},
	}
	win.SendInput(uint32(len(input)), unsafe.Pointer(&input[0]), int32(unsafe.Sizeof(input[0])))
}

// Create a transparent overlay window
func createOverlayWindow() win.HWND {
	className := windows.StringToUTF16Ptr("OverlayClass")
	windowName := windows.StringToUTF16Ptr("OverlayWindow")

	// Register the window class
	var wc win.WNDCLASSEX
	wc.CbSize = uint32(unsafe.Sizeof(wc))
	wc.LpszClassName = className
	wc.HInstance = win.GetModuleHandle(nil)
	wc.Style = win.CS_HREDRAW | win.CS_VREDRAW
	wc.LpfnWndProc = syscall.NewCallback(wndProc)
	win.RegisterClassEx(&wc)

	// Create the window
	hwnd := win.CreateWindowEx(
		win.WS_EX_LAYERED|win.WS_EX_TRANSPARENT|win.WS_EX_TOPMOST,
		className,
		windowName,
		win.WS_POPUP,
		0, 0, screenWidth, screenHeight,
		0, 0, wc.HInstance, nil,
	)

	// Make the window transparent
	const LWA_ALPHA = 0x00000002
	user32 := windows.NewLazySystemDLL("user32.dll")
	setLayeredWindowAttributes := user32.NewProc("SetLayeredWindowAttributes")
	setLayeredWindowAttributes.Call(
		uintptr(hwnd),
		0,
		255,
		LWA_ALPHA,
	)

	// Set window to be transparent and layered
	type MARGINS struct {
		Left, Right, Top, Bottom int32
	}
	margins := MARGINS{-1, -1, -1, -1}
	dwmExtendFrameIntoClientArea := windows.NewLazySystemDLL("dwmapi.dll").NewProc("DwmExtendFrameIntoClientArea")
	dwmExtendFrameIntoClientArea.Call(uintptr(hwnd), uintptr(unsafe.Pointer(&margins)))

	win.ShowWindow(hwnd, win.SW_SHOW)
	return hwnd
}

// Window procedure callback
func wndProc(hwnd win.HWND, msg uint32, wParam, lParam uintptr) uintptr {
	switch msg {
	case win.WM_DESTROY:
		win.PostQuitMessage(0)
		return 0
	}
	return win.DefWindowProc(hwnd, msg, wParam, lParam)
}

// Fetch entity data for overlay
func fetchEntityData(handle windows.Handle, clientBase uintptr) []struct {
	ID     int32
	Health int32
	IsSpec bool
} {
	entities := []struct {
		ID     int32
		Health int32
		IsSpec bool
	}{}

	// Constants for offsets
	m_iHealth := uintptr(0x344)
	m_iTeamNum := uintptr(0x3E3)
	m_hPlayerPawn := uintptr(0x80C)

	// Get local player first
	localPlayerAddress := clientBase + uintptr(offsets.ClientDLL["dwLocalPlayerPawn"])
	localPlayer, err := ReadUint64(handle, localPlayerAddress)
	if err != nil || localPlayer == 0 {
		return entities
	}

	// Get local team
	localTeam, err := ReadInt32(handle, uintptr(localPlayer)+m_iTeamNum)
	if err != nil {
		return entities
	}

	// Get EntityList base
	entityList := clientBase + uintptr(offsets.ClientDLL["dwEntityList"])
	entity, err := ReadUint64(handle, entityList)
	if err != nil {
		return entities
	}

	// Loop through possible entities
	for i := 0; i < 64; i++ {
		// Get list entity
		listEntityAddr := entity + uint64((8*(i&0x7FFF)>>9)+16)
		listEntity, err := ReadUint64(handle, uintptr(listEntityAddr))
		if err != nil || listEntity == 0 {
			continue
		}

		// Get entity controller
		entityControllerAddr := listEntity + uint64(120*(i&0x1FF))
		entityController, err := ReadUint64(handle, uintptr(entityControllerAddr))
		if err != nil || entityController == 0 {
			continue
		}

		// Get controller pawn
		entityControllerPawn, err := ReadUint64(handle, uintptr(entityController)+m_hPlayerPawn)
		if err != nil || entityControllerPawn == 0 {
			continue
		}

		// Get list entity for pawn
		listEntityPawnAddr := entity + uint64(0x8*((entityControllerPawn&0x7FFF)>>9)+16)
		listEntityPawn, err := ReadUint64(handle, uintptr(listEntityPawnAddr))
		if err != nil || listEntityPawn == 0 {
			continue
		}

		// Get entity pawn
		entityPawnAddr := listEntityPawn + uint64(120*(entityControllerPawn&0x1FF))
		entityPawn, err := ReadUint64(handle, uintptr(entityPawnAddr))
		if err != nil || entityPawn == 0 {
			continue
		}

		// Read team and health
		team, err := ReadInt32(handle, uintptr(entityPawn)+m_iTeamNum)
		if err != nil {
			continue
		}

		health, err := ReadInt32(handle, uintptr(entityPawn)+m_iHealth)
		if err != nil || health <= 0 || health > 100 {
			continue
		}

		// Skip if it's the same team (unless spectator)
		if team == localTeam {
			continue
		}

		// Check if spectator (team 1)
		isSpec := team == 1

		// Only add if it's an enemy or spectator
		entities = append(entities, struct {
			ID     int32
			Health int32
			IsSpec bool
		}{ID: team, Health: health, IsSpec: isSpec})
	}

	return entities
}

// Render entity data on the overlay
func renderOverlay(hwnd win.HWND, entityData []struct {
	ID     int32
	Health int32
	IsSpec bool
}) {
	// Create an offscreen image for rendering
	dc := gg.NewContext(screenWidth, screenHeight)
	dc.SetRGBA(0, 0, 0, 0) // Transparent background
	dc.Clear()

	// Calculate box dimensions
	padding := 10.0
	lineHeight := 20.0
	boxWidth := 200.0
	numEntities := len(entityData)
	boxHeight := float64(numEntities)*lineHeight + 2*padding

	// Draw semi-transparent background box
	dc.SetRGBA(0, 0, 0, 0.5) // Black with 50% opacity
	dc.DrawRectangle(340, 440, boxWidth, boxHeight)
	dc.Fill()

	// Render each entity's ID and health in a list
	yOffset := 450.0
	for _, entity := range entityData {
		if entity.Health > 0 {
			color := getColor(entity.Health, entity.IsSpec)
			text := fmt.Sprintf("ID: %d, Health: %d", entity.ID, entity.Health)
			dc.SetColor(color)
			dc.DrawStringAnchored(text, 350, yOffset, 0, 0.5)
			yOffset += lineHeight
		}
	}

	img := dc.Image().(*image.RGBA)

	// Get the window device context
	hdc := win.GetDC(hwnd)
	if hdc == 0 {
		return
	}
	defer win.ReleaseDC(hwnd, hdc)

	// Create compatible DC and bitmap
	memDC := win.CreateCompatibleDC(hdc)
	if memDC == 0 {
		return
	}
	defer win.DeleteDC(memDC)

	hBitmap := win.CreateBitmap(screenWidth, screenHeight, 1, 32, unsafe.Pointer(&img.Pix[0]))
	if hBitmap == 0 {
		return
	}
	defer win.DeleteObject(win.HGDIOBJ(hBitmap))

	oldBitmap := win.SelectObject(memDC, win.HGDIOBJ(hBitmap))
	win.BitBlt(hdc, 0, 0, screenWidth, screenHeight, memDC, 0, 0, win.SRCCOPY)
	win.SelectObject(memDC, oldBitmap)
}

func getColor(health int32, isSpec bool) color.RGBA {
	if isSpec {
		return color.RGBA{255, 192, 203, 255} // Pink for spectators
	}
	if health < 50 {
		return color.RGBA{255, 0, 0, 255}
	} else if health < 75 {
		return color.RGBA{255, 255, 0, 255}
	}
	return color.RGBA{0, 255, 0, 255}
}

// TriggerBot functionality
func TriggerBot(handle windows.Handle, clientBase uintptr) {
	for {
		// Check if ALT key is pressed (most significant bit indicates if key is down)
		if win.GetKeyState(win.VK_MENU)&-32768 == 0 { // Using -32768 instead of 0x8000
			time.Sleep(10 * time.Millisecond)
			continue
		}

		// Constants for offsets
		m_iHealth := uintptr(0x344)
		m_iTeamNum := uintptr(0x3E3)
		m_iIDEntIndex := uintptr(0x1458)

		// Get local player
		localPlayerAddress := clientBase + uintptr(offsets.ClientDLL["dwLocalPlayerPawn"])
		localPlayer, err := ReadUint64(handle, localPlayerAddress)
		if err != nil || localPlayer == 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}

		// Get crosshair handle
		crosshairHandle, err := ReadInt32(handle, uintptr(localPlayer)+m_iIDEntIndex)
		if err != nil || crosshairHandle <= 0 {
			time.Sleep(10 * time.Millisecond)
			continue
		}

		// Get EntityList base and pointer
		entityList := clientBase + uintptr(offsets.ClientDLL["dwEntityList"])
		entity, err := ReadUint64(handle, entityList)
		if err != nil {
			time.Sleep(10 * time.Millisecond)
			continue
		}

		// Store initial entity information
		initialCrosshairHandle := crosshairHandle

		// Get list entity
		listEntityAddr := entity + uint64(8*(crosshairHandle>>9)+16)
		listEntity, err := ReadUint64(handle, uintptr(listEntityAddr))
		if err != nil || listEntity == 0 {
			continue
		}

		// Get entity
		entityAddr := listEntity + uint64(120*(crosshairHandle&0x1FF))
		baseEntity, err := ReadUint64(handle, uintptr(entityAddr))
		if err != nil || baseEntity == 0 {
			continue
		}

		// Read enemy team and health
		enemyTeam, err := ReadInt32(handle, uintptr(baseEntity)+m_iTeamNum)
		if err != nil {
			continue
		}

		localTeam, err := ReadInt32(handle, uintptr(localPlayer)+m_iTeamNum)
		if err != nil {
			continue
		}

		enemyHealth, err := ReadInt32(handle, uintptr(baseEntity)+m_iHealth)
		if err != nil {
			continue
		}

		// Check initial conditions
		if enemyHealth <= 0 || enemyHealth > 100 || enemyTeam == localTeam {
			continue
		}

		// Wait 75ms and recheck
		time.Sleep(15 * time.Millisecond)
		// Make sure ALT is still held down
		if win.GetKeyState(win.VK_MENU)&-32768 == 0 {
			continue
		}

		// Recheck crosshair target
		newCrosshairHandle, err := ReadInt32(handle, uintptr(localPlayer)+m_iIDEntIndex)
		if err != nil || newCrosshairHandle != initialCrosshairHandle {
			continue
		}

		// If target is still valid, shoot
		simulateMouseClick()
		time.Sleep(100 * time.Millisecond) // Delay between shots
	}
}

func main() {
	offsetURL := "https://raw.githubusercontent.com/sezzyaep/CS2-OFFSETS/main/offsets.json"
	if err := fetchOffsets(offsetURL); err != nil {
		fmt.Printf("Error fetching offsets: %s\n", err)
		return
	}

	processName := "cs2.exe"
	processID, err := getProcessIdByName(processName)
	if err != nil {
		fmt.Printf("Failed to find process: %s\n", err)
		return
	}

	processHandle, err := windows.OpenProcess(windows.PROCESS_ALL_ACCESS, false, processID)
	if err != nil {
		fmt.Printf("Failed to open process: %s\n", processName)
		return
	}
	defer windows.CloseHandle(processHandle)

	clientBase, err := getModuleBaseAddress(processHandle, "client.dll")
	if err != nil {
		fmt.Println(err)
		fmt.Printf("Failed to get client.dll base address\n")
		return
	}

	hwnd := createOverlayWindow()
	if hwnd == 0 {
		fmt.Println("Failed to create overlay window")
		return
	}

	// Message loop in the main thread
	go func() {
		for {
			entityData := fetchEntityData(processHandle, clientBase)
			win.SendMessage(hwnd, win.WM_PAINT, 0, 0)
			renderOverlay(hwnd, entityData)
			time.Sleep(16 * time.Millisecond)
		}
	}()

	go TriggerBot(processHandle, clientBase)

	// Main message loop
	var msg win.MSG
	for {
		if win.GetMessage(&msg, 0, 0, 0) != 0 {
			win.TranslateMessage(&msg)
			win.DispatchMessage(&msg)
		}
	}
}

func getModuleBaseAddress(processHandle windows.Handle, moduleName string) (uintptr, error) {
	processID, err := windows.GetProcessId(processHandle)
	if err != nil {
		return 0, fmt.Errorf("failed to get process ID: %w", err)
	}

	hSnapshot, err := windows.CreateToolhelp32Snapshot(windows.TH32CS_SNAPMODULE|windows.TH32CS_SNAPMODULE32, processID)
	if err != nil {
		return 0, fmt.Errorf("failed to create snapshot: %w", err)
	}
	defer windows.CloseHandle(hSnapshot)

	var moduleEntry windows.ModuleEntry32
	moduleEntry.Size = uint32(unsafe.Sizeof(moduleEntry))

	// Iterate through the modules to find the specified one
	if err := windows.Module32First(hSnapshot, &moduleEntry); err != nil {
		return 0, fmt.Errorf("failed to get first module: %w", err)
	}

	for {
		// Convert the module name to a Go string
		moduleNameFromEntry := windows.UTF16ToString(moduleEntry.Module[:])

		// Check if this is the module we're looking for
		if moduleNameFromEntry == moduleName {
			return uintptr(moduleEntry.ModBaseAddr), nil
		}

		// Proceed to the next module
		if err := windows.Module32Next(hSnapshot, &moduleEntry); err != nil {
			break
		}
	}

	return 0, fmt.Errorf("module %s not found", moduleName)
}

func getProcessIdByName(processName string) (uint32, error) {
	snapshot, err := windows.CreateToolhelp32Snapshot(windows.TH32CS_SNAPPROCESS, 0)
	if err != nil {
		return 0, err
	}
	defer windows.CloseHandle(snapshot)

	var pe windows.ProcessEntry32
	pe.Size = uint32(unsafe.Sizeof(pe))

	if err := windows.Process32First(snapshot, &pe); err != nil {
		return 0, err
	}

	for {
		foundProcessName := windows.UTF16ToString(pe.ExeFile[:])
		if foundProcessName == processName {
			fmt.Printf("Found process: %s with PID: %d\n", foundProcessName, pe.ProcessID)
			return pe.ProcessID, nil
		}
		err = windows.Process32Next(snapshot, &pe)
		if err != nil {
			if err == windows.ERROR_NO_MORE_FILES {
				return 0, fmt.Errorf("process not found: %s", processName)
			}
			return 0, err
		}
	}
}
